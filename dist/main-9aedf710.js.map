{"version":3,"file":"main-9aedf710.js","sources":["../src/lib/focusable.ts","../src/lib/debounce.ts","../src/lib/focus-trap.ts","../src/lib/shadow.ts"],"sourcesContent":["/**\n * Returns whether the element is hidden.\n * @param $elem\n */\nexport function isHidden ($elem: HTMLElement): boolean {\n\treturn $elem.hasAttribute(\"hidden\")\n\t\t|| ($elem.hasAttribute(\"aria-hidden\") && $elem.getAttribute(\"aria-hidden\") !== \"false\")\n\n\t\t// A quick and dirty way to check whether the element is hidden.\n\t\t// For a more fine-grained check we could use \"window.getComputedStyle\" but we don't because of bad performance.\n\t\t// If the element has visibility set to \"hidden\" or \"collapse\", display set to \"none\" or opacity set to \"0\" through CSS\n\t\t// we won't be able to catch it here. We accept it due to the huge performance benefits.\n\t\t|| $elem.style.display === `none`\n\t\t|| $elem.style.opacity === `0`\n\t\t|| $elem.style.visibility === `hidden`\n\t\t|| $elem.style.visibility === `collapse`;\n}\n\n/**\n * Returns whether the element is disabled.\n * @param $elem\n */\nexport function isDisabled ($elem: HTMLElement): boolean {\n\treturn $elem.hasAttribute(\"disabled\")\n\t\t|| ($elem.hasAttribute(\"aria-disabled\") && $elem.getAttribute(\"aria-disabled\") !== \"false\");\n}\n\n/**\n * Determines whether an element is focusable.\n * Read more here: https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus/1600194#1600194\n * Or here: https://stackoverflow.com/questions/18261595/how-to-check-if-a-dom-element-is-focusable\n * @param $elem\n */\nexport function isFocusable ($elem: HTMLElement): boolean {\n\n\t// Discard elements that are removed from the tab order.\n\tif ($elem.getAttribute(\"tabindex\") === \"-1\" || isHidden($elem) || isDisabled($elem)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\n\t\t// At this point we know that the element can have focus (eg. won't be -1) if the tabindex attribute exists\n\t\t$elem.hasAttribute(\"tabindex\")\n\n\t\t// Anchor tags or area tags with a href set\n\t\t|| ($elem instanceof HTMLAnchorElement || $elem instanceof HTMLAreaElement) && $elem.hasAttribute(\"href\")\n\n\t\t// Form elements which are not disabled\n\t\t|| ($elem instanceof HTMLButtonElement\n\t\t\t|| $elem instanceof HTMLInputElement\n\t\t\t|| $elem instanceof HTMLTextAreaElement\n\t\t\t|| $elem instanceof HTMLSelectElement)\n\n\t\t// IFrames\n\t\t|| $elem instanceof HTMLIFrameElement\n\t);\n}\n","let timeouts = new Map<string, number>();\n\n/**\n * Debounces a callback.\n * @param cb\n * @param ms\n * @param id\n */\nexport function debounce (cb: (() => void), ms: number, id: string) {\n\n\t// Clear current timeout for id\n\tconst timeout = timeouts.get(id);\n\tif (timeout != null) {\n\t\twindow.clearTimeout(timeout);\n\t}\n\n\t// Set new timeout\n\ttimeouts.set(id, window.setTimeout(() => {\n\t\tcb();\n\t\ttimeouts.delete(id);\n\t}, ms));\n}\n\n","import { debounce } from \"./debounce\";\nimport { isFocusable, isHidden } from \"./focusable\";\nimport { queryShadowRoot } from \"./shadow\";\n\nexport interface IFocusTrap {\n  inactive: boolean;\n  readonly focused: boolean;\n  focusFirstElement: () => void;\n  focusLastElement: () => void;\n  getFocusableElements: () => HTMLElement[];\n}\n\n/**\n * Template for the focus trap.\n */\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n\t<div id=\"start\"></div>\n\t<slot></slot>\n\t<div id=\"backup\"></div>\n\t<div id=\"end\"></div>\n`;\n\n/**\n * Focus trap web component.\n * @slot - Default content.\n */\nexport class FocusTrap extends HTMLElement implements IFocusTrap {\n  // Whenever one of these attributes changes we need to render the template again.\n  static get observedAttributes() {\n    return [\"inactive\"];\n  }\n\n  /**\n   * Determines whether the focus trap is active or not.\n   * @attr\n   */\n  get inactive() {\n    return this.hasAttribute(\"inactive\");\n  }\n\n  set inactive(value: boolean) {\n    value\n      ? this.setAttribute(\"inactive\", \"\")\n      : this.removeAttribute(\"inactive\");\n  }\n\n  // The backup element is only used if there are no other focusable children\n  private $backup!: HTMLElement;\n\n  // The debounce id is used to distinguish this focus trap from others when debouncing\n  private debounceId = Math.random().toString();\n\n  private $start!: HTMLElement;\n  private $end!: HTMLElement;\n\n  private _focused = false;\n\n  /**\n   * Returns whether the element currently has focus.\n   */\n  get focused(): boolean {\n    return this._focused;\n  }\n\n  /**\n   * Attaches the shadow root.\n   */\n  constructor() {\n    super();\n\n    const shadow = this.attachShadow({ mode: \"open\" });\n    shadow.appendChild(template.content.cloneNode(true));\n\n    this.focusLastElement = this.focusLastElement.bind(this);\n    this.focusFirstElement = this.focusFirstElement.bind(this);\n    this.onFocusIn = this.onFocusIn.bind(this);\n    this.onFocusOut = this.onFocusOut.bind(this);\n  }\n\n  /**\n   * Hooks up the element.\n   */\n  connectedCallback() {\n    this.$backup = this.shadowRoot!.querySelector<HTMLElement>(\"#backup\")!;\n    this.$start = this.shadowRoot!.querySelector<HTMLElement>(\"#start\")!;\n    this.$end = this.shadowRoot!.querySelector<HTMLElement>(\"#end\")!;\n\n    this.$start.addEventListener(\"focus\", this.focusLastElement);\n    this.$end.addEventListener(\"focus\", this.focusFirstElement);\n\n    // Focus out is called every time the user tabs around inside the element\n    this.addEventListener(\"focusin\", this.onFocusIn);\n    this.addEventListener(\"focusout\", this.onFocusOut);\n\n    this.render();\n  }\n\n  /**\n   * Tears down the element.\n   */\n  disconnectedCallback() {\n    this.$start.removeEventListener(\"focus\", this.focusLastElement);\n    this.$end.removeEventListener(\"focus\", this.focusFirstElement);\n    this.removeEventListener(\"focusin\", this.onFocusIn);\n    this.removeEventListener(\"focusout\", this.onFocusOut);\n  }\n\n  /**\n   * When the attributes changes we need to re-render the template.\n   */\n  attributeChangedCallback() {\n    this.render();\n  }\n\n  /**\n   * Focuses the first focusable element in the focus trap.\n   */\n  focusFirstElement() {\n    this.trapFocus();\n  }\n\n  /**\n   * Focuses the last focusable element in the focus trap.\n   */\n  focusLastElement() {\n    this.trapFocus(true);\n  }\n\n  /**\n   * Returns a list of the focusable children found within the element.\n   */\n  getFocusableElements(): HTMLElement[] {\n    return queryShadowRoot(this, isHidden, isFocusable);\n  }\n\n  /**\n   * Focuses on either the last or first focusable element.\n   * @param {boolean} trapToEnd\n   */\n  protected trapFocus(trapToEnd?: boolean) {\n    if (this.inactive) return;\n\n    let focusableChildren = this.getFocusableElements();\n    if (focusableChildren.length > 0) {\n      if (trapToEnd) {\n        focusableChildren[focusableChildren.length - 1].focus();\n      } else {\n        focusableChildren[0].focus();\n      }\n\n      this.$backup.setAttribute(\"tabindex\", \"-1\");\n    } else {\n      // If there are no focusable children we need to focus on the backup\n      // to trap the focus. This is a useful behavior if the focus trap is\n      // for example used in a dialog and we don't want the user to tab\n      // outside the dialog even though there are no focusable children\n      // in the dialog.\n      this.$backup.setAttribute(\"tabindex\", \"0\");\n      this.$backup.focus();\n    }\n  }\n\n  /**\n   * When the element gains focus this function is called.\n   */\n  private onFocusIn() {\n    this.updateFocused(true);\n  }\n\n  /**\n   * When the element looses its focus this function is called.\n   */\n  private onFocusOut() {\n    this.updateFocused(false);\n  }\n\n  /**\n   * Updates the focused property and updates the view.\n   * The update is debounced because the focusin and focusout out\n   * might fire multiple times in a row. We only want to render\n   * the element once, therefore waiting until the focus is \"stable\".\n   * @param value\n   */\n  private updateFocused(value: boolean) {\n    debounce(\n      () => {\n        if (this.focused !== value) {\n          this._focused = value;\n          this.render();\n        }\n      },\n      0,\n      this.debounceId\n    );\n  }\n\n  /**\n   * Updates the template.\n   */\n  protected render() {\n    if (!this.isConnected) return;\n    this.$start.setAttribute(\n      \"tabindex\",\n      !this.focused || this.inactive ? `-1` : `0`\n    );\n    this.$end.setAttribute(\n      \"tabindex\",\n      !this.focused || this.inactive ? `-1` : `0`\n    );\n    this.focused\n      ? this.setAttribute(\"focused\", \"\")\n      : this.removeAttribute(\"focused\");\n  }\n}\n\nif (window && window.customElements) {\n  window.customElements.define(\"focus-trap\", FocusTrap);\n}\n","/**\n * Traverses the slots of the open shadowroots and returns all children matching the query.\n * @param {ShadowRoot | HTMLElement} root\n * @param skipNode\n * @param isMatch\n * @param {number} maxDepth\n * @param {number} depth\n * @returns {HTMLElement[]}\n */\nexport function queryShadowRoot (root: ShadowRoot | HTMLElement,\n                                 skipNode: (($elem: HTMLElement) => boolean),\n                                 isMatch: (($elem: HTMLElement) => boolean),\n                                 maxDepth: number = 20,\n                                 depth: number = 0): HTMLElement[] {\n\tlet matches: HTMLElement[] = [];\n\n\t// If the depth is above the max depth, abort the searching here.\n\tif (depth >= maxDepth) {\n\t\treturn matches;\n\t}\n\n\t// Traverses a slot element\n\tconst traverseSlot = ($slot: HTMLSlotElement) => {\n\n\t\t// Only check nodes that are of the type Node.ELEMENT_NODE\n\t\t// Read more here https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n\t\tconst assignedNodes = $slot.assignedNodes().filter(node => node.nodeType === 1);\n\t\tif (assignedNodes.length > 0) {\n\t\t\treturn queryShadowRoot(assignedNodes[0].parentElement!, skipNode, isMatch, maxDepth, depth + 1);\n\t\t}\n\n\t\treturn [];\n\t};\n\n\t// Go through each child and continue the traversing if necessary\n\t// Even though the typing says that children can't be undefined, Edge 15 sometimes gives an undefined value.\n\t// Therefore we fallback to an empty array if it is undefined.\n\tconst children = <HTMLElement[]>Array.from(root.children || []);\n\tfor (const $child of children) {\n\n\t\t// Check if the node and its descendants should be skipped\n\t\tif (skipNode($child)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If the child matches we always add it\n\t\tif (isMatch($child)) {\n\t\t\tmatches.push($child);\n\t\t}\n\n\t\tif ($child.shadowRoot != null) {\n\t\t\tmatches.push(...queryShadowRoot($child.shadowRoot, skipNode, isMatch, maxDepth, depth + 1));\n\n\t\t} else if ($child.tagName === \"SLOT\") {\n\t\t\tmatches.push(...traverseSlot(<HTMLSlotElement>$child));\n\n\t\t} else {\n\t\t\tmatches.push(...queryShadowRoot($child, skipNode, isMatch, maxDepth, depth + 1));\n\t\t}\n\t}\n\n\treturn matches;\n}\n"],"names":["isHidden","$elem","hasAttribute","getAttribute","style","display","opacity","visibility","isFocusable","isDisabled","HTMLAnchorElement","HTMLAreaElement","HTMLButtonElement","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","HTMLIFrameElement","timeouts","Map","template","document","createElement","innerHTML","FocusTrap","HTMLElement","constructor","debounceId","Math","random","toString","_focused","this","attachShadow","mode","appendChild","content","cloneNode","focusLastElement","bind","focusFirstElement","onFocusIn","onFocusOut","value","setAttribute","removeAttribute","connectedCallback","$backup","shadowRoot","querySelector","$start","$end","addEventListener","render","disconnectedCallback","removeEventListener","attributeChangedCallback","trapFocus","getFocusableElements","queryShadowRoot","root","skipNode","isMatch","maxDepth","depth","matches","traverseSlot","$slot","assignedNodes","filter","node","nodeType","length","parentElement","children","Array","from","$child","push","tagName","trapToEnd","inactive","focusableChildren","focus","updateFocused","cb","ms","id","timeout","get","window","clearTimeout","set","setTimeout","delete","debounce","focused","isConnected","customElements","define"],"mappings":"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"}